
一期加固对应的工程位置：https://192.168.52.2:8443/svn/移动APP加固系统/研发/工程源码/android/InfoSafeJiaGuApp

# 系统环境部署和依赖库
系统镜像版本：`CentOS 7 1908` 需要自己在服务器上安装相应系统
web服务位置：`/www/server/tomcat/webapps/appjg/`，数据库部署在机房另一台数据库服务器中。相关代码在SVN库中(https://192.168.52.2:8443/svn/移动APP加固系统/研发/工程源码/server/reinforce)。**数据库信息未知**。web服务搭建有点复杂，没有涉及。web服务部署文件：`/home/www/`
一期加固后台访问地址及帐号：  
http://192.168.51.210:8080/appjg/  
root  
root123  
```sh
[root@localhost mis]# uname
Linux
[root@localhost mis]# lsb_release -a
-bash: lsb_release: 未找到命令
[root@localhost mis]# uname -a
Linux localhost.localdomain 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
[root@localhost mis]# uname -r
3.10.0-957.21.3.el7.x86_64
[root@localhost mis]# cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
[root@localhost mis]# rpm -q centos-release
centos-release-7-6.1810.2.el7.centos.x86_64
[root@localhost mis]# rpm -q redhat-release
未安装软件包 redhat-release
[root@localhost mis]# cat /proc/version
Linux version 3.10.0-957.21.3.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Tue Jun 18 16:35:19 UTC 2019
```

依赖库
```sh
[root@localhost mis]# java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
[root@localhost mis]#
[root@localhost mis]# which zip
/usr/bin/zip
[root@localhost mis]# which unzip
/usr/bin/unzip
[root@localhost mis]# which keytool
/usr/bin/keytool
[root@localhost mis]#
[root@localhost mis]# zip --version
Copyright (c) 1990-2008 Info-ZIP - Type 'zip "-L"' for software license.
This is Zip 3.0 (July 5th 2008), by Info-ZIP.
Currently maintained by E. Gordon.  Please send bug reports to
the authors using the web page at www.info-zip.org; see README for details.

Latest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,
as of above date; see http://www.info-zip.org/ for other sites.

Compiled with gcc 4.8.5 20150623 (Red Hat 4.8.5-11) for Unix (Linux ELF) on Nov  5 2016.

Zip special compilation options:
        USE_EF_UT_TIME       (store Universal Time)
        BZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)
            bzip2 code and library copyright (c) Julian R Seward
            (See the bzip2 license for terms of use)
        SYMLINK_SUPPORT      (symbolic links supported)
        LARGE_FILE_SUPPORT   (can read and write large files on file system)
        ZIP64_SUPPORT        (use Zip64 to store large files in archives)
        UNICODE_SUPPORT      (store and read UTF-8 Unicode paths)
        STORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)
        UIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)
        [encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)

Encryption notice:
        The encryption code of this program is not copyrighted and is
        put in the public domain.  It was originally written in Europe
        and, to the best of our knowledge, can be freely distributed
        in both source and object forms from any country, including
        the USA under License Exception TSU of the U.S. Export
        Administration Regulations (section 740.13(e)) of 6 June 2002.

Zip environment options:
             ZIP:  [none]
          ZIPOPT:  [none]
[root@localhost mis]# unzip --version
caution:  both -n and -o specified; ignoring -o
UnZip 6.00 of 20 April 2009, by Info-ZIP.  Maintained by C. Spieler.  Send
bug reports using http://www.info-zip.org/zip-bug.html; see README for details.

Usage: unzip [-Z] [-opts[modifiers]] file[.zip] [list] [-x xlist] [-d exdir]
  Default action is to extract files in list, except those in xlist, to exdir;
  file[.zip] may be a wildcard.  -Z => ZipInfo mode ("unzip -Z" for usage).

  -p  extract files to pipe, no messages     -l  list files (short format)
  -f  freshen existing files, create none    -t  test compressed archive data
  -u  update files, create if necessary      -z  display archive comment only
  -v  list verbosely/show version info       -T  timestamp archive to latest
  -x  exclude files that follow (in xlist)   -d  extract files into exdir
modifiers:
  -n  never overwrite existing files         -q  quiet mode (-qq => quieter)
  -o  overwrite files WITHOUT prompting      -a  auto-convert any text files
  -j  junk paths (do not make directories)   -aa treat ALL files as text
  -U  use escapes for all non-ASCII Unicode  -UU ignore any Unicode fields
  -C  match filenames case-insensitively     -L  make (some) names lowercase
  -X  restore UID/GID info                   -V  retain VMS version numbers
  -K  keep setuid/setgid/tacky permissions   -M  pipe through "more" pager
  -O CHARSET  specify a character encoding for DOS, Windows and OS/2 archives
  -I CHARSET  specify a character encoding for UNIX and other archives

See "unzip -hh" or unzip.txt for more help.  Examples:
  unzip data1 -x joe   => extract all files except joe from zipfile data1.zip
  unzip -p foo | more  => send contents of foo.zip via pipe into program more
  unzip -fo foo ReadMe => quietly replace existing ReadMe if archive file newer
[root@localhost mis]#
```

`rm` `cp` `mv`


```sh
[root@localhost mis]# /mis/android/tools/aapt/aapt v
Android Asset Packaging Tool, v0.2-eng.ibotpe.20190216.092407
[root@localhost mis]# java -jar /mis/android/tools/apktool/apktool.jar -v
Apktool v2.4.0 - a tool for reengineering Android apk files
with smali v2.2.6 and baksmali v2.2.6
Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
Updated by Connor Tumbleson <connor.tumbleson@gmail.com>

usage: apktool
 -advance,--advanced   prints advance information.
 -version,--version    prints the version then exits
usage: apktool if|install-framework [options] <framework.apk>
 -p,--frame-path <dir>   Stores framework files into <dir>.
 -t,--tag <tag>          Tag frameworks using <tag>.
usage: apktool d[ecode] [options] <file_apk>
 -f,--force              Force delete destination directory.
 -o,--output <dir>       The name of folder that gets written. Default is apk.out
 -p,--frame-path <dir>   Uses framework files located in <dir>.
 -r,--no-res             Do not decode resources.
 -s,--no-src             Do not decode sources.
 -t,--frame-tag <tag>    Uses framework files tagged by <tag>.
usage: apktool b[uild] [options] <app_path>
 -f,--force-all          Skip changes detection and build all files.
 -o,--output <dir>       The name of apk that gets written. Default is dist/name.apk
 -p,--frame-path <dir>   Uses framework files located in <dir>.

For additional info, see: http://ibotpeaches.github.io/Apktool/
For smali/baksmali info, see: https://github.com/JesusFreke/smali
[root@localhost mis]# java -jar /mis/android/tools/baksmali/baksmali.jar --version
baksmali 2.2.7 (http://smali.org)
Copyright (C) 2010 Ben Gruver (JesusFreke@JesusFreke.com)
BSD license (http://www.opensource.org/licenses/bsd-license.php)
[root@localhost mis]# java -jar /mis/android/tools/smali/smali.jar --version
smali 2.2.7 (http://smali.org)
Copyright (C) 2010 Ben Gruver (JesusFreke@JesusFreke.com)
BSD license (http://www.opensource.org/licenses/bsd-license.php)
[root@localhost mis]#
```






# 加固原理概述
## 一、占位
1. 把自己新建的类反编译成smali之后添加到原始apk反编译出来的smali目录中，其中我们自己类的包名为 `a.a.a.a.a.a.a.a.a.a` 迫使反编译工具第一时间处理的是我们事先准备好的类。
2. 把我们定制的类的smali代码加入到用户反编译出来的smali目录中，然后把smali回编译成dex，然后修改我们自己定制的类里面的字节码，可以改为任意字节码，因为我们事先准备的类不会被调用。因为我们包名特殊，位于包内最前面的位置，所以反编译工具会第一时间解析我们定制的那个类，但是我们的类里面字节码有变化，甚至根本就不是dex字节码，就会自己导致反编译工具出错退出，从而防止了对目标字节码的反编译。
3. 使用dex修复工具修复dex文件中的校验信息。

## 二、resources.arsc 文件后面新增4个0字节
1. 原始`resources.arsc`新增4个字节在手机上的解析是正常的，但是在反编译工具验证`resources.arsc`信息时，会发现文件实际大小跟头部信息里面的文件大小不对，从而解析失败。




# 目录结构及文件介绍
`/home/MPJAPIPB` 这个目录下有个测试JAR包`appJgApi-1.0.jar`
测试命令如下：
`java -classpath /home/MPJAPIPB/appJgApi-1.0.jar c.k.s.f.k.api.MN /mis/android/reinforce/apk/source/1000/1000.apk`



Android 加固部分位于`/mis/android`
其中`tools`目录下(`/mis/android/tools`)包含`aapt`、`apktool`、`baksmali`、`smali`工具，各版本号见依赖库部分。



辅助文件位置：
```sh
[root@localhost reinforce]# ls -al /mis/android/reinforce/file
总用量 0
drwsrwsrwt  6 root root  56 7月   3 2019 .
drwsrwsrwt  4 root root  29 7月   3 2019 ..
drwsrwsrwt  2 root root  19 7月   3 2019 resed
drwsrwsrwt  2 root root  87 7月   3 2019 sign
drwsrwsrwt 10 root root 133 7月   3 2019 smali
drwsrwsrwt  2 root root   6 7月   3 2019 temp
[root@localhost reinforce]# ls -al /mis/android/reinforce/file/resed/
总用量 4
drwsrwsrwt 2 root root 19 7月   3 2019 .
drwsrwsrwt 6 root root 56 7月   3 2019 ..
-rwsrwsrwt 1 root root  4 7月   3 2019 ed.b4
[root@localhost reinforce]# ls -al /mis/android/reinforce/file/sign/
总用量 24
drwsrwsrwt 2 root root   87 7月   3 2019 .
drwsrwsrwt 6 root root   56 7月   3 2019 ..
-rwsrwsrwt 1 root root 2227 7月   3 2019 JMKEY.jks
-rwsrwsrwt 1 root root 1216 7月   3 2019 platform.pk8
-rwsrwsrwt 1 root root 1675 7月   3 2019 platform.x509.pem
-rwsrwsrwt 1 root root 8986 7月   3 2019 signapk.jar
[root@localhost reinforce]# ls -al /mis/android/reinforce/file/temp/
总用量 0
drwsrwsrwt 2 root root  6 7月   3 2019 .
drwsrwsrwt 6 root root 56 7月   3 2019 ..
[root@localhost reinforce]# ls -al /mis/android/reinforce/file/smali/
总用量 0
drwsrwsrwt 10 root root 133 7月   3 2019 .
drwsrwsrwt  6 root root  56 7月   3 2019 ..
drwsrwsrwt  3 root root  17 7月   3 2019 Application
drwsrwsrwt  3 root root  17 7月   3 2019 BuildConfig
drwsrwsrwt  3 root root  15 7月   3 2019 cs2dxsi
drwsrwsrwt  3 root root  15 7月   3 2019 cs3dxsi
drwsrwsrwt  3 root root  15 7月   3 2019 cs4dxsi
drwsrwsrwt  3 root root  15 7月   3 2019 cs5dxsi
drwsrwsrwt  3 root root  15 7月   3 2019 cs6dxsi
drwsrwsrwt  4 root root  24 8月  14 2019 csdxsi
[root@localhost reinforce]#
```

其中`/mis/android/reinforce/file/resed/ed.b4`文件中存放的是4个0字节，后面处理时会使用`cat`命令把这个文件中的4个0字节追加到`resources.arsc`文件末尾。





工作目录位于：`/mis/android/reinforce/apk/`
1. 应用进行加固时，会在`/mis/android/reinforce/apk/source/`目录下产生一个工作目录，以`apk_文件MD5值_文件大小_文件CRC`组成的目录，并把apk复制一份改名为`source.apk`存入工作目录中。
    ```sh
    [root@localhost mis]# ls -al /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/
    总用量 118324
    drwxr-s---  5 root root      241 8月  19 10:07 .
    drwsrwsrwt 27 root root     4096 8月  30 16:51 ..
    -rw-r-----  1 root root     1130 8月  19 10:05 analysisApk.sh
    -rw-r-----  1 root root    27194 8月  19 10:05 AndroidManifest-info.txt
    -rw-r-----  1 root root      805 8月  19 10:05 apksigner.txt
    -rw-r-----  1 root root     3148 8月  19 10:05 AppInfo.json
    -rw-r-----  1 root root 30327615 8月  19 10:07 jmc.apk
    -rw-r-----  1 root root 30270019 8月  19 10:07 mtk.apk
    drwxr-s--- 11 root root      257 8月  19 10:07 new
    -rw-r-----  1 root root 30203248 8月  19 10:07 new.apk
    drwxr-s--- 11 root root      257 8月  19 10:05 out
    -rw-r-----  1 root root     2410 8月  19 10:05 permissions.txt
    -rw-r-----  1 root root     7843 8月  19 10:05 pkginfo.txt
    drwxr-s---  4 root root       57 8月  19 10:06 smali
    -rw-r-----  1 root root 30295970 8月  19 10:05 source.apk
    [root@localhost mis]#
    ```
    其中jmc.apk是使用毛祥提供的签名信息签名的包，mtk.apk是使用平台签名的包，new.apk是没有签名的包。
    其中new.apk是从source.apk中复制过来，并使用zip工具删除包中的签名信息，然后使用new目录中相应的dex、`resources.arsc`文件回写。


2. 会生成`analysisApk.sh`脚本，以使用相应工具从apk中提取相应信息。产生的内容为：
    ```sh
    [root@localhost mis]# cat /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/analysisApk.sh
    cd /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305
    /usr/bin/keytool -list -printcert -jarfile /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/source.apk > /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/apksigner.txt
    /mis/android/tools/aapt/aapt dump badging /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/source.apk > /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/pkginfo.txt
    /mis/android/tools/aapt/aapt dump permissions /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/source.apk > /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/permissions.txt
    /mis/android/tools/aapt/aapt dump xmltree /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/source.apk AndroidManifest.xml > /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/AndroidManifest-info.txt
    exit
    [root@localhost mis]#
    ```
    即会产生`apksigner.txt`、`pkginfo.txt`、`permissions.txt`、`AndroidManifest-info.txt`四个文件。  
    即使用keytool工具获取到签名的MD5、SHA1、SHA256的值
    其中`AppInfo.json`是由`c.k.s.f.m.m.analysis.AnalysisApkControl`中的`public String analysis(String apkPath,String apkDir,String appInfoPath)`方法使用产生的4个文件从中提取所需信息，最后写回文件。


3. 使用zip把source.apk解压到out目录中，

4. 使用baksmali工具，把out目录中的dex文件进行反编译，输入到smali目录中，名称以原文件名后加--smali组成，每个dex单独一个目录。
    ```sh
    [root@localhost mis]# ls -al /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/smali/
    总用量 0
    drwxr-s--- 4 root root  57 8月  19 10:06 .
    drwxr-s--- 5 root root 241 8月  19 10:07 ..
    drwxr-s--- 4 root root  26 8月  19 10:06 classes2.dex-smali
    drwxr-s--- 5 root root  35 8月  19 10:06 classes.dex-smali
    [root@localhost mis]#
    ```


5. 把`/mis/android/reinforce/file/smali/csdxsi/`目录中的目录拷贝到第一个dex产生的smali目录中，即`smali/classes.dex-smali/`中，从`/mis/android/reinforce/file/smali/csXXXdxsi/`目录中随机(**对应索引值?????**)选择一个，把目录中的文件拷贝到其他smali目录中，即`smali/classesXXX.dex-smali/`
    ```sh
    [root@localhost smali]# ls -aR classes.dex-smali/
    classes.dex-smali/:
    .  ..  a  com  m

    classes.dex-smali/a:
    .  ..  a  AAAWA.smali

    classes.dex-smali/a/a:
    .  ..  a

    classes.dex-smali/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a/a/a/a/a:
    .  ..  a

    classes.dex-smali/a/a/a/a/a/a/a/a/a/a/a:
    .  ..  a  A.smali

    classes.dex-smali/a/a/a/a/a/a/a/a/a/a/a/a:
    .  ..  A.smali

    classes.dex-smali/com:
    .  ..  session  tencent  wrapper

    classes.dex-smali/com/session:
    .  ..  html

    classes.dex-smali/com/session/html:
    .  ..  BuildConfig.smali  MyWrapperProxyApplication.smali

    classes.dex-smali/com/tencent:
    .  ..  StubShell

    classes.dex-smali/com/tencent/StubShell:
    .  ..  TxAppEntry.smali

    classes.dex-smali/com/wrapper:
    .  ..  proxyapplication

    classes.dex-smali/com/wrapper/proxyapplication:
    .                          MultiDexForMemoryDex.smali               MultiDexForTinker.smali      MultiDex$V19.smali      WrapperProxyApplication.smali
    ..                         MultiDexForMemoryDex$V26.smali           MultiDexForTinker$V19.smali  MultiDex$V4.smali
    AndroidNClassLoader.smali  MultiDexForTinkerForMemoryDex.smali      MultiDexForTinker$V4.smali   ShareReflectUtil.smali
    CustomerClassLoader.smali  MultiDexForTinkerForMemoryDex$V26.smali  MultiDex.smali               Util.smali

    classes.dex-smali/m:
    .  ..  p

    classes.dex-smali/m/p:
    .  ..  c

    classes.dex-smali/m/p/c:
    .  ..  s

    classes.dex-smali/m/p/c/s:
    .  ..  a

    classes.dex-smali/m/p/c/s/a:
    .  ..  f

    classes.dex-smali/m/p/c/s/a/f:
    .  ..  e

    classes.dex-smali/m/p/c/s/a/f/e:
    .  ..  c

    classes.dex-smali/m/p/c/s/a/f/e/c:
    .  ..  p

    classes.dex-smali/m/p/c/s/a/f/e/c/p:
    .  ..  m

    classes.dex-smali/m/p/c/s/a/f/e/c/p/m:
    .  ..  BC.smali  MPC$1.smali  MPC.smali  SC.smali  SCT.smali
    [root@localhost smali]#
    ```


    ```sh
    [root@localhost smali]# ls -aR classes2.dex-smali/
    classes2.dex-smali/:
    .  ..  a  com

    classes2.dex-smali/a:
    .  ..  a  AAAWB.smali

    classes2.dex-smali/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a/a/a/a/a:
    .  ..  a

    classes2.dex-smali/a/a/a/a/a/a/a/a/a/a/a:
    .  ..  a  B.smali

    classes2.dex-smali/a/a/a/a/a/a/a/a/a/a/a/a:
    .  ..  B.smali

    classes2.dex-smali/com:
    .  ..  example

    classes2.dex-smali/com/example:
    .  ..  helloworld

    classes2.dex-smali/com/example/helloworld:
    .  ..  BuildConfig.smali  R$attr.smali  R$dimen.smali  R$drawable.smali  R$id.smali  R$menu.smali  R.smali  R$string.smali  R$style.smali
    [root@localhost smali]#

    ```


6. 把`out/resources.arsc`文件后追加4个0字节后写入到`new/resources.arsc`中
    ```sh
    [root@localhost mis]# ls -al /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/out/resources.arsc
    -rw-rw-r-- 1 root root 617808 8月  19 10:00 /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/out/resources.arsc
    [root@localhost mis]# ls -al /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/new/resources.arsc
    -rw-r----- 1 root root 617812 8月  19 10:06 /mis/android/reinforce/apk/source/apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305/new/resources.arsc
    [root@localhost mis]#
    ```
    可以看出new目录中`resources.arsc`的明显比原始文件多出4个字节。


7. 把smali目录中smali文件回编译成dex，放入new目录中，然后处理事先准备好的类中的方法的字节码，替换成任意字节，并修复dex文件中的hash值。


8. 从source.apk中复制一份改名为new.apk，使用zip工具删除new.apk中的签名信息，然后使用new目录中相应处理过的文件回写到new.apk中(assets目录中有些文件不能进行压缩)


9.  使用相应签名工具进行签名。



# 问题
1. 签名信息，签名白名单的增加，处理 

2. 当用户dex中的方法书接近限定值时，再往里面添加我们自己的代码会导致方法数目超过限定值，从而造成回编译成dex失败。此时可能需要把超过限定值的dex进行分包处理!!!!!
3. 处理的dex数目上限为6，有些大包，包含许多dex文件的apk可能处理不了。每个dex文件中新增的待修改字节码的smali文件是否不一样，是否需要自己手动生成？添加的方法？？？`/home/MPJMCLOW/` `/home/MPJMCLOW-ONCE/`
    1. 需要编译工程并反编译，取出相应smali组成对应目录。

4. 物理机器操作(刀片服务器操作，开关机，后面按钮拨一下，前面开关按钮按)、机器配置？？（路由配置？？）
5. 加固一期后台部分，访问地址跟端口号，后台代码
6. `appJgApi-1.0.jar`路径？？？ `/home/MPJAPIPB/appJgApi-1.0.jar` 
7. 签名问题梳理，可以使用keytool获取签名的hash值，包含MD5、SHA1、SHA256。但是没有找到相应可供调用的api
    1. 可以直接使用keytool工具对解压出来的 `META-INF/GUANGMIN.RSA` 即`RSA`后缀的文件提取公钥hash值。
    ```sh
    [root@localhost apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305]# keytool -printcert -jarfile source.apk
    签名者 #1:

    签名:

    所有者: CN=Session, OU=Session, O=Session, L=ShenZhen, ST=SZ, C=CN
    发布者: CN=Session, OU=Session, O=Session, L=ShenZhen, ST=SZ, C=CN
    序列号: 3cb1eaf8
    有效期开始日期: Mon Sep 26 11:34:42 CST 2016, 截止日期: Fri Sep 20 11:34:42 CST 2041
    证书指纹:
            MD5: 6E:DB:6D:57:6F:CB:32:03:6F:DA:EA:29:72:97:CC:B9
            SHA1: A7:82:84:4C:F5:71:2C:86:5F:82:CD:61:59:B1:EB:45:72:86:29:28
            SHA256: E0:4C:54:B1:0E:A7:59:E5:C1:9B:44:27:22:0B:B9:B2:5F:E6:A0:87:C5:C8:7C:FA:A3:41:DC:7E:1A:A2:F5:A0
            签名算法名称: SHA256withRSA
            版本: 3

    扩展:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 1E 80 35 6F E9 BD 22 10   C9 70 0D 01 0F E3 B0 3D  ..5o.."..p.....=
    0010: F3 8D 0C 54                                        ...T
    ]
    ]


    [root@localhost apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305]# keytool -printcert -file ./out/META-INF/GUANGMIN.RSA
    所有者: CN=Session, OU=Session, O=Session, L=ShenZhen, ST=SZ, C=CN
    发布者: CN=Session, OU=Session, O=Session, L=ShenZhen, ST=SZ, C=CN
    序列号: 3cb1eaf8
    有效期开始日期: Mon Sep 26 11:34:42 CST 2016, 截止日期: Fri Sep 20 11:34:42 CST 2041
    证书指纹:
            MD5: 6E:DB:6D:57:6F:CB:32:03:6F:DA:EA:29:72:97:CC:B9
            SHA1: A7:82:84:4C:F5:71:2C:86:5F:82:CD:61:59:B1:EB:45:72:86:29:28
            SHA256: E0:4C:54:B1:0E:A7:59:E5:C1:9B:44:27:22:0B:B9:B2:5F:E6:A0:87:C5:C8:7C:FA:A3:41:DC:7E:1A:A2:F5:A0
            签名算法名称: SHA256withRSA
            版本: 3

    扩展:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 1E 80 35 6F E9 BD 22 10   C9 70 0D 01 0F E3 B0 3D  ..5o.."..p.....=
    0010: F3 8D 0C 54                                        ...T
    ]
    ]

    [root@localhost apk_02F4277D2896C14ACF60D5AFD51944D8_30295970_136672305]#
    ```






# 工程分析
一共有两个工程，MPJAPIPB(main project jiagu API public) 和 MPJMCLOW。

## MPJAPIPB编译生成最终的 appJgApi-1.0.jar 可以直接在命令行中使用，也可以提供给后台进行集成。
### 工程编译
1. 导入Android Studio
2. 选择项目`MPJAPIPB`，`Build` -> `Generate Signed Bundle / APK...` -> 在弹出的对话框中选择`APK`并点击`Next` -> 添加签名文件跟签名相应信息
3. `Build Variants`选择`release`，并勾选下面的`V1(Jar Signature` `V2(Full Apk Signature)`
4. 编译后的`jar`文件路径位于：`InfoSafeJiaGuApp\MPJAPIPB\build\intermediates\transforms\mergeJavaRes\release\0.jar`或`InfoSafeJiaGuApp\MPJAPIPB\build\intermediates\transforms\proguard\release\0.jar`
6. 相应的`mapping`文件位于：`InfoSafeJiaGuApp\MPJAPIPB\build\outputs\mapping\release\mapping.txt`

### 代码相关类介绍
1. `c.k.s.f.k.api`中包含3个类`MN.java` `RB.java` `RF.java`
   1. `c.k.s.f.k.api.MN`提供了命令行调用的方式。
   2. `c.k.s.f.k.api.RB`为回调类，后台传入这个类的实例来获取加固过程中的状态等信息。
   3. `c.k.s.f.k.api.RF`里面提供两种接口，区别在于线程的管理方式。`public static void rf(String apkPath,RB rb,String userjson)`需要调用者管理线程池。而`public static void rftd(final String apkPath,final RB rb,final String userjson)`是自己使用线程运行。



`c.k.s.f.m.m.main.MainControl`即为最终执行加固功能的类。此类实现了`public void reinforce(String sourceApkPath, RB rb, String userjson)`
   1. `public void parsingSignatureConfig(String basePath,JSONObject appInfoJson)`解析待加固apk的签名信息，并把相应签名信息的hash值写入到另一个工程的占坑类（smali）中。
   2. `public void parsingLaunchableActivity(String basePath,JSONObject appInfoJson)`找到Activity的入口点，添加我们的入口到相应位置。
   3. `public void parsingApplicationPath(String applicationSmaliPath)`根据找到的application smali文件位置，插入我们的代码。
   4. `public void parsingApplication(String basePath,JSONObject appInfoJson)` 解析目标apk中的application入口，并调用`parsingApplicationPath`添加我们的入口到相应位置。
   5. `public void parsingBuildConfig(String basePath,JSONObject appInfoJson)`去除包中的可调试信息
   6. `public void reinforce(String sourceApkPath, RB rb, String userjson)`具体的加固流程。




`c.k.s.f.m.m.path.PathControl`包含目录信息和使用到的工具的路径

`c.k.s.f.m.m.dexcheck.RPDBControl`中的`public ArrayList<RPDBInfo> getRPDBInfoList(int type)`方法参数type为dex的索引值。

`c.k.s.f.m.m.analysis.ParserControl`中的`public static SignatureInfo parserSignatureInfo(String str)`方法从先前产生的`apksigner.txt`中解析出签名的MD5、SHA1、SHA256等hash值，然后依次调用`FileTools.gsmc(md5, 4);` `FileTools.gsmc(sha1, 4);` `FileTools.gsmc(sha256, 4);`再计算各个hash值的hash，**其中计算次数在这个地方写死的4次，跟后面一个工程中`SC`类的字段`ct = 4`是匹配的**。




## 加固流程
1. 只要工作目录中存在`AppInfo.json`和`new.apk`则认为已经加固过，直接跳过处理步骤。目录创建方式为:`apk_MD5_size_crc`
2. 调用`c.k.s.f.m.m.analysis.AnalysisApkControl`中的`public String analysis(String apkPath,String apkDir,String appInfoPath)`分析apk中相应的信息。
   1. 创建脚本文件`analysisApk.sh`，使用脚本文件解析apk相应信息，产生`apksigner.txt`、`pkginfo.txt`、`permissions.txt`、`AndroidManifest-info.txt`，解析产生的文件中的信息并回调给web。
3. 使用`zip`解压`source.apk`到`out`目录，并验证是否存在相应特定文件，即检测是否是合法apk文件。
4. 创建`new`目录，并把`out`目录的内容全部拷贝过去。
5. 把文件`edb4`追加到`out/resources.arsc`中，并存入`new`目录下，即`new/resources.arsc`。即往待加固apk中的`resources.arsc`文件后面追加4个0字节。
6. 反编译classes.dex文件，并将其他dex文件也进行反编译，classes.dex需要单独处理，把`csdex`目录中的内容拷贝到`classes.dex`反编译的目录中。然后循环6次，把`csXXXdex`拷贝到相应索引dex反编译出的smali目录中。
    ```sh
    [root@localhost reinforce]# ls -al /mis/android/reinforce/file/smali/
    总用量 0
    drwsrwsrwt 10 root root 133 7月   3 2019 .
    drwsrwsrwt  6 root root  56 7月   3 2019 ..
    drwsrwsrwt  3 root root  17 7月   3 2019 Application
    drwsrwsrwt  3 root root  17 7月   3 2019 BuildConfig
    drwsrwsrwt  3 root root  15 7月   3 2019 cs2dxsi
    drwsrwsrwt  3 root root  15 7月   3 2019 cs3dxsi
    drwsrwsrwt  3 root root  15 7月   3 2019 cs4dxsi
    drwsrwsrwt  3 root root  15 7月   3 2019 cs5dxsi
    drwsrwsrwt  3 root root  15 7月   3 2019 cs6dxsi
    drwsrwsrwt  4 root root  24 8月  14 2019 csdxsi
    [root@localhost reinforce]#
    ```
7. 解析buildConfig,application,activity,signature信息后回编译成相应的dex文件，存放`new`目录中，其中回编译的出来的classes.dex是单独处理的。
    1. 检测`BuildConfig`中`DEBUG`是否为`false`，如果为`true`则修改为`false`, 如果没有相应字段，则添加字段值为`false`。
    2. 针对`application`，寻找入口函数，并在入口处插入`Lm/p/c/s/a/f/e/c/p/m/MPC;->f(Landroid/content/Context;)V`调用
    3. 同样针对`parsingLaunchableActivity`，寻找入口函数，并在入口处插入`Lm/p/c/s/a/f/e/c/p/m/MPC;->f(Landroid/content/Context;)V`调用
    4. 针对`signature`,寻找`SC`类对应的smali文件路径，用之前获取到的签名信息，给`SC`类中相应字段赋值。分别给相应字段`s11` `s12` `s13`赋值。`scString = new ReplaceStringControl().replace(scString,".field private static s11:Ljava/lang/String; = \"\"",".field private static s11:Ljava/lang/String; = \""+s11+"\"");`
8.  使用`c.k.s.f.m.m.dexcheck.DexCheckControl`中的方法修改`new`目录中回编译的dex中无用的方法中的字节码，（直接通过相应字节码二进制进行定位）替换成任意二进制，并修复dex文件中头部的hash值。其中classes.dex是单独处理，其他dex是批量处理。
9.  拷贝一份`source.apk`文件到`new`目录中并重命名为`new.apk`。使用`zip`工具删除`new`目录下`new.apk`中的签名信息，并使用此目录下的dex文件和`resources.arsc`更新apk中的dex和`resources.arsc`，使用相应签名文件进行签名。
10. 返回最终签名后的apk文件路径。


## MPJMCLOW 为需要提取smali代码插入到目标apk中的代码，我们自己的入口。最终生成的文件进入到`/mis/android/reinforce/file/smali/`中
1. `com.infosafe.mpjmc` 中的类`MainActivity`和`MPCApplication`是需要编译出apk处理并反编译成smali代码，并没有最终插入到用户代码中，只是在这两个类中调用防护代码，方便之后把调用方式（smali代码）拷贝一份，后续把这种调用方式的smali代码插入到待加固app的入口。即没有使用这两个类，仅仅只是用来产生smali调用方式的代码，便于把调用方式的smali代码插入到待加固apk中去。
2. 另一个包`m.p.c.s.a.f.e.c.p.m`中的类分别为：
   1. `BC.java`获取`pkgName.BuildConfig`中的DEBUG字段的值；暂时没有发现被调用的地方。  
      1. 获取`BuildConfig`中的`DEBUG`字段值，查看是否是可调试。
   2. `MPC.java`为反调试、自退出功能；其中包含对海云安检测app的包名判断，发现海云安的包则直接自杀。
      1. 判断签名
      2. 检测当前app是否是可调试，`appInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE`
      3. 读`/proc/PID/status`检测`TracerPid`
      4. 检测是否存在包名`com.itsec.marsproject`，存在则退出进程。通过使用获取pkgname对应的签名还判断是否有安装相应的包。
      5. 使用`am force stop Package pkgname`结束进程，
      6. 单独开一个线程，每隔一段时间使用`Debug.isDebuggerConnected()`检测是否有调试器附加。
   3. `SC.java`为一个占坑类，后续会通过解析apk，把原始apk中的签名信息回填到这个类对应的smali代码中，即赋值给`s11`,`s12`,`s13`并最终和原始apk中的代码一起进行回编译； 其中`s11`,`s12`,`s13`为从原始apk中提取的签名信息的hash值——MD5，SHA1，SHA256的值，`s1`,`s2`,`s3`则为apk实际运行时获取到的相应签名信息的hash值。其中定义了处理hash值的次数（ct）。成员变量`k`是检测那几个签名白名单，值为`7`，对应的二进制为`111`需要跟签名白名单中的索引进行`&`运算以判断是否需要校验这个签名，也即校验索引为`1` `2` `4`的签名。
   4. `SCT.java`为具体获取apk运行时签名信息，比较签名信息的类；入口方法为`public static boolean cas(Context c)`，被`MPC`类调用。`SCT`中包含一个签名白名单`tsklist`。即处于白名单中的签名信息就可以过签名校验。`tsklist`中的主要字段为签名的MD5、SHA1、SHA256值。白名单中的`mpjmc`即为毛祥提供的签名信息。
      1. 获取签名信息并计算出签名信息的MD5、SHA1、SHA256值，与白名单中的签名hash值比对。
3. 包`a`中的类都是无用代码，即没有任何有效调用方。这个包内的类里面的方法体内内容一致，基本都是调用系统api，是为了让其在生成dex时，固定其字节码，便于后续的查找和替换。这个包中的类会反编译成smali代码，插入到目标apk反编译的smali中，最后同目标smali一起回编译成dex，然后在回编译的dex中查找固定的字节码，即我们准备的不会被有效调用的那些类中的方法内的字节码，并使用随机字节替换，最后修正dex中的hash值后存入new文件夹中。








